// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.4.1
// - protoc             v3.21.5
// source: valuation/v1/good.proto

package valuation

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationGoodCreateGood = "/api.valuation.Good/CreateGood"
const OperationGoodDeleteGood = "/api.valuation.Good/DeleteGood"
const OperationGoodGetGood = "/api.valuation.Good/GetGood"
const OperationGoodListGoods = "/api.valuation.Good/ListGoods"
const OperationGoodListGoodsByWords = "/api.valuation.Good/ListGoodsByWords"
const OperationGoodUpdateGood = "/api.valuation.Good/UpdateGood"

type GoodHTTPServer interface {
	CreateGood(context.Context, *CreateGoodsRequest) (*CreateGoodsReply, error)
	DeleteGood(context.Context, *DeleteGoodsRequest) (*DeleteGoodsReply, error)
	GetGood(context.Context, *GetGoodsRequest) (*GetGoodsReply, error)
	ListGoods(context.Context, *ListGoodsRequest) (*ListGoodsReply, error)
	ListGoodsByWords(context.Context, *ListGoodsByWordsRequest) (*ListGoodsByWordsReply, error)
	UpdateGood(context.Context, *UpdateGoodsRequest) (*UpdateGoodsReply, error)
}

func RegisterGoodHTTPServer(s *http.Server, srv GoodHTTPServer) {
	r := s.Route("/")
	r.POST("/good", _Good_CreateGood0_HTTP_Handler(srv))
	r.PUT("/good", _Good_UpdateGood0_HTTP_Handler(srv))
	r.DELETE("/good/{id}", _Good_DeleteGood0_HTTP_Handler(srv))
	r.GET("", _Good_GetGood0_HTTP_Handler(srv))
	r.GET("/good/list", _Good_ListGoods0_HTTP_Handler(srv))
	r.GET("/good/list/{words}", _Good_ListGoodsByWords0_HTTP_Handler(srv))
}

func _Good_CreateGood0_HTTP_Handler(srv GoodHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CreateGoodsRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationGoodCreateGood)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateGood(ctx, req.(*CreateGoodsRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*CreateGoodsReply)
		return ctx.Result(200, reply)
	}
}

func _Good_UpdateGood0_HTTP_Handler(srv GoodHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UpdateGoodsRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationGoodUpdateGood)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateGood(ctx, req.(*UpdateGoodsRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UpdateGoodsReply)
		return ctx.Result(200, reply)
	}
}

func _Good_DeleteGood0_HTTP_Handler(srv GoodHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DeleteGoodsRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationGoodDeleteGood)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeleteGood(ctx, req.(*DeleteGoodsRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*DeleteGoodsReply)
		return ctx.Result(200, reply)
	}
}

func _Good_GetGood0_HTTP_Handler(srv GoodHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetGoodsRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationGoodGetGood)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetGood(ctx, req.(*GetGoodsRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetGoodsReply)
		return ctx.Result(200, reply)
	}
}

func _Good_ListGoods0_HTTP_Handler(srv GoodHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListGoodsRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationGoodListGoods)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListGoods(ctx, req.(*ListGoodsRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListGoodsReply)
		return ctx.Result(200, reply)
	}
}

func _Good_ListGoodsByWords0_HTTP_Handler(srv GoodHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListGoodsByWordsRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationGoodListGoodsByWords)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListGoodsByWords(ctx, req.(*ListGoodsByWordsRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListGoodsByWordsReply)
		return ctx.Result(200, reply)
	}
}

type GoodHTTPClient interface {
	CreateGood(ctx context.Context, req *CreateGoodsRequest, opts ...http.CallOption) (rsp *CreateGoodsReply, err error)
	DeleteGood(ctx context.Context, req *DeleteGoodsRequest, opts ...http.CallOption) (rsp *DeleteGoodsReply, err error)
	GetGood(ctx context.Context, req *GetGoodsRequest, opts ...http.CallOption) (rsp *GetGoodsReply, err error)
	ListGoods(ctx context.Context, req *ListGoodsRequest, opts ...http.CallOption) (rsp *ListGoodsReply, err error)
	ListGoodsByWords(ctx context.Context, req *ListGoodsByWordsRequest, opts ...http.CallOption) (rsp *ListGoodsByWordsReply, err error)
	UpdateGood(ctx context.Context, req *UpdateGoodsRequest, opts ...http.CallOption) (rsp *UpdateGoodsReply, err error)
}

type GoodHTTPClientImpl struct {
	cc *http.Client
}

func NewGoodHTTPClient(client *http.Client) GoodHTTPClient {
	return &GoodHTTPClientImpl{client}
}

func (c *GoodHTTPClientImpl) CreateGood(ctx context.Context, in *CreateGoodsRequest, opts ...http.CallOption) (*CreateGoodsReply, error) {
	var out CreateGoodsReply
	pattern := "/good"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationGoodCreateGood))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *GoodHTTPClientImpl) DeleteGood(ctx context.Context, in *DeleteGoodsRequest, opts ...http.CallOption) (*DeleteGoodsReply, error) {
	var out DeleteGoodsReply
	pattern := "/good/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationGoodDeleteGood))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *GoodHTTPClientImpl) GetGood(ctx context.Context, in *GetGoodsRequest, opts ...http.CallOption) (*GetGoodsReply, error) {
	var out GetGoodsReply
	pattern := ""
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationGoodGetGood))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *GoodHTTPClientImpl) ListGoods(ctx context.Context, in *ListGoodsRequest, opts ...http.CallOption) (*ListGoodsReply, error) {
	var out ListGoodsReply
	pattern := "/good/list"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationGoodListGoods))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *GoodHTTPClientImpl) ListGoodsByWords(ctx context.Context, in *ListGoodsByWordsRequest, opts ...http.CallOption) (*ListGoodsByWordsReply, error) {
	var out ListGoodsByWordsReply
	pattern := "/good/list/{words}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationGoodListGoodsByWords))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *GoodHTTPClientImpl) UpdateGood(ctx context.Context, in *UpdateGoodsRequest, opts ...http.CallOption) (*UpdateGoodsReply, error) {
	var out UpdateGoodsReply
	pattern := "/good"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationGoodUpdateGood))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PUT", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}
